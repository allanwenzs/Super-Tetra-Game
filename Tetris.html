<!doctype html>
<html lang="en">
<head>
  <link rel="manifest" href="manifest.json">
  <meta name="theme-color" content="#0b1020">

  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"/>
  <title>Super Tetra Game </title>
  <style>
    :root{
      --bg0:#0b1020;
      --bg1:#0f1833;
      --text:#e9eeff;
      --muted:#93a0d8;
      --shadow: 0 20px 60px rgba(0,0,0,.45);
      --radius: 18px;
      --glass: linear-gradient(180deg, rgba(17,26,60,.92), rgba(11,19,47,.88));
      --glass2: linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.02));
    }
    *{ box-sizing:border-box; }
    html,body{ height:100%; }
    body{
      margin:0;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial;
      color:var(--text);
      background:
        radial-gradient(1200px 800px at 20% 10%, #22306a 0%, transparent 60%),
        radial-gradient(1200px 800px at 80% 30%, #4b1b7a 0%, transparent 55%),
        radial-gradient(1200px 800px at 50% 100%, #0c5d6a 0%, transparent 55%),
        linear-gradient(180deg, var(--bg0), var(--bg1));
      display:flex;
      align-items:center;
      justify-content:center;
      padding:18px;
    }
    .app{
      width:min(1180px, 100%);
      display:grid;
      grid-template-columns: 1fr 420px;
      gap:18px;
      align-items:stretch;
    }
    @media (max-width: 980px){
      .app{ grid-template-columns: 1fr; }
      .side{ order:-1; }
    }
    .card{
      background: var(--glass);
      border:1px solid rgba(255,255,255,.08);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      overflow:hidden;
      backdrop-filter: blur(10px);
    }
    .boardWrap{ position:relative; padding:14px; }
    canvas#game{
      width:100%;
      height:auto;
      display:block;
      border-radius: 14px;
      background: linear-gradient(180deg, rgba(10,16,40,.95), rgba(7,12,30,.96));
      box-shadow: inset 0 0 0 1px rgba(255,255,255,.06);
      touch-action:none;
    }

    .hud{
      display:grid;
      grid-template-rows: auto auto auto 1fr auto;
      gap:14px;
      padding:16px;
    }
    .titleRow{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:12px;
    }
    .logo{ display:flex; gap:10px; align-items:center; }
    .badge{
      width:40px;height:40px;border-radius:12px;
      background: linear-gradient(135deg, rgba(90,255,255,.18), rgba(255,90,255,.15));
      border:1px solid rgba(255,255,255,.10);
      display:grid;place-items:center;
      box-shadow: 0 10px 30px rgba(0,0,0,.25);
    }
    h1{ margin:0; font-size:18px; letter-spacing:.3px; line-height:1.1; }
    .sub{ margin-top:2px; color:var(--muted); font-size:12px; }

    .pill{
      font-size:12px;
      color: rgba(255,255,255,.92);
      background: linear-gradient(180deg, rgba(255,255,255,.10), rgba(255,255,255,.04));
      border:1px solid rgba(255,255,255,.10);
      border-radius: 999px;
      padding:8px 10px;
      display:flex;
      align-items:center;
      gap:8px;
      user-select:none;
      white-space:nowrap;
    }
    .pill b{ font-weight:900; }

    .stats{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:12px;
    }
    .stat{
      padding:12px;
      border-radius: 14px;
      background: linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.03));
      border:1px solid rgba(255,255,255,.08);
      box-shadow: inset 0 0 0 1px rgba(255,255,255,.03);
    }
    .stat.full{ grid-column: 1 / -1; }
    .stat .k{
      color:var(--muted);
      font-size:12px;
      margin-bottom:6px;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:8px;
    }
    .stat .v{ font-size:20px; font-weight:900; letter-spacing:.2px; }
    .stat .subv{
      margin-top:6px;
      font-size:12px;
      color:rgba(233,238,255,.78);
      display:flex;
      justify-content:space-between;
      gap:10px;
      flex-wrap:wrap;
    }

    .panel{
      padding:12px;
      border-radius: 14px;
      background: var(--glass2);
      border:1px solid rgba(255,255,255,.08);
    }
    .panel h3{
      margin:0 0 10px 0;
      font-size:12px;
      color:var(--muted);
      letter-spacing:.4px;
      text-transform:uppercase;
      display:flex;
      justify-content:space-between;
      align-items:center;
      gap:10px;
      flex-wrap:wrap;
    }
    .miniRow{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:12px;
      align-items:stretch;
    }
    .miniBox{
      display:grid;
      grid-template-rows:auto 1fr;
      gap:8px;
    }
    .miniLabel{
      font-size:12px;
      color:var(--muted);
      display:flex;
      justify-content:space-between;
      align-items:center;
      padding:0 2px;
      gap:10px;
      flex-wrap:wrap;
    }
    .miniCanvas{
      width:100%;
      border-radius: 14px;
      background: linear-gradient(180deg, rgba(10,16,40,.85), rgba(7,12,30,.92));
      box-shadow: inset 0 0 0 1px rgba(255,255,255,.06);
      border:1px solid rgba(255,255,255,.06);
      display:block;
    }

    .help{
      color:var(--muted);
      font-size:12px;
      line-height:1.45;
    }
    .help kbd{
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace;
      font-size:11px;
      padding:2px 6px;
      border-radius:8px;
      background: rgba(255,255,255,.08);
      border:1px solid rgba(255,255,255,.10);
      color: rgba(255,255,255,.9);
      white-space:nowrap;
    }

    .footerRow{
      display:flex;
      justify-content:space-between;
      align-items:center;
      gap:10px;
      color:var(--muted);
      font-size:12px;
      padding-top:4px;
      flex-wrap:wrap;
    }
    .btn{
      cursor:pointer;
      border:none;
      border-radius: 12px;
      padding:10px 12px;
      color: rgba(255,255,255,.92);
      background: linear-gradient(135deg, rgba(108,255,214,.18), rgba(115,139,255,.18));
      border:1px solid rgba(255,255,255,.12);
      box-shadow: 0 16px 40px rgba(0,0,0,.25);
      transition: transform .12s ease, filter .12s ease, opacity .12s ease;
      user-select:none;
      white-space:nowrap;
    }
    .btn:active{ transform: translateY(1px) scale(.99); filter: brightness(.98); }
    .btn:disabled{ opacity:.45; cursor:not-allowed; }

    .toggle, select, input[type="range"]{ font-size:12px; }
    .toggle{
      cursor:pointer;
      padding:8px 10px;
      border-radius: 12px;
      border:1px solid rgba(255,255,255,.12);
      background: rgba(255,255,255,.06);
      color: rgba(255,255,255,.92);
      user-select:none;
      white-space:nowrap;
    }
    .toggle.on{
      background: linear-gradient(135deg, rgba(120,255,220,.18), rgba(160,180,255,.18));
      border-color: rgba(255,255,255,.16);
    }
    select{
      cursor:pointer;
      padding:8px 10px;
      border-radius: 12px;
      border:1px solid rgba(255,255,255,.12);
      background: rgba(255,255,255,.06);
      color: rgba(255,255,255,.92);
      outline:none;
    }
    .row{ display:flex; gap:10px; align-items:center; flex-wrap:wrap; }

    .overlay{
      position:absolute;
      inset:14px;
      border-radius: 14px;
      display:none;
      align-items:center;
      justify-content:center;
      background: radial-gradient(800px 500px at 50% 30%, rgba(120,160,255,.18) 0%, rgba(10,16,40,.85) 55%, rgba(7,12,30,.92) 100%);
      backdrop-filter: blur(6px);
      border:1px solid rgba(255,255,255,.08);
      z-index:20;
    }
    .overlay.show{ display:flex; }

    .modal{
      width:min(560px, 92%);
      border-radius: 18px;
      padding:16px;
      background: linear-gradient(180deg, rgba(16,26,58,.92), rgba(11,19,47,.90));
      border:1px solid rgba(255,255,255,.10);
      box-shadow: var(--shadow);
    }
    .modal .big{
      font-size:34px;
      font-weight:900;
      letter-spacing:.5px;
      margin:8px 0 2px;
      background: linear-gradient(90deg, rgba(160,255,230,1), rgba(180,190,255,1), rgba(255,170,240,1));
      -webkit-background-clip: text;
      background-clip: text;
      color:transparent;
      text-align:center;
    }
    .modal .miniStats{
      display:flex;
      justify-content:center;
      gap:12px;
      flex-wrap:wrap;
      margin:6px 0 10px;
      color:rgba(233,238,255,.86);
      font-size:13px;
    }
    .modal .miniStats b{ color: rgba(255,255,255,.95); }

    .toast{
      position:absolute;
      left:50%;
      top:18px;
      transform: translateX(-50%);
      padding:8px 10px;
      border-radius: 999px;
      background: rgba(0,0,0,.35);
      border: 1px solid rgba(255,255,255,.10);
      color: rgba(255,255,255,.92);
      font-size:12px;
      display:none;
      gap:8px;
      align-items:center;
      user-select:none;
      z-index:25;
      white-space:nowrap;
    }
    .toast.show{ display:flex; }
    .dot{
      width:8px;height:8px;border-radius:50%;
      background: rgba(120,255,200,.85);
      box-shadow: 0 0 18px rgba(120,255,200,.55);
    }

    .leader{
      margin-top:12px;
      padding:12px;
      border-radius: 14px;
      background: rgba(255,255,255,.05);
      border:1px solid rgba(255,255,255,.08);
    }
    .leader h4{
      margin:0 0 8px 0;
      font-size:12px;
      color:var(--muted);
      letter-spacing:.4px;
      text-transform:uppercase;
    }
    .leader ol{
      margin:0;
      padding-left:18px;
      color: rgba(255,255,255,.92);
      font-size:13px;
      line-height:1.55;
    }
    .leader small{ color:var(--muted); }

    .settingsGrid{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:10px;
    }
    .setting{
      padding:10px;
      border-radius: 14px;
      background: rgba(255,255,255,.05);
      border:1px solid rgba(255,255,255,.08);
    }
    .setting .k{
      color:var(--muted);
      font-size:12px;
      margin-bottom:8px;
      display:flex;
      justify-content:space-between;
      align-items:center;
      gap:10px;
    }
    .setting .k b{ color:rgba(233,238,255,.9); font-weight:900; }
    input[type="range"]{ width:100%; }

    .bindGrid{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:10px;
    }
    .bindRow{
      padding:10px;
      border-radius: 14px;
      background: rgba(255,255,255,.05);
      border:1px solid rgba(255,255,255,.08);
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
    }
    .bindRow .k{
      font-size:12px;
      color:var(--muted);
    }
    .bindKey{
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace;
      font-size:11px;
      padding:6px 8px;
      border-radius:10px;
      background: rgba(255,255,255,.08);
      border:1px solid rgba(255,255,255,.12);
      color: rgba(255,255,255,.92);
      cursor:pointer;
      user-select:none;
      white-space:nowrap;
    }
    .bindKey.listening{
      outline: 2px solid rgba(120,255,220,.55);
      box-shadow: 0 0 0 6px rgba(120,255,220,.10);
    }
  </style>
</head>

<body>
  <div class="app">
    <div class="card boardWrap">
      <div class="toast" id="toast"><span class="dot"></span><span id="toastText">Paused</span></div>

      <canvas id="game" width="360" height="720" aria-label="Tetris board"></canvas>

      <div class="overlay" id="overlayGameOver">
        <div class="modal">
          <div class="big" id="finalScore">0</div>
          <div class="miniStats">
            <span>High: <b id="finalHigh">0</b></span>
            <span>Level: <b id="finalLevel">1</b></span>
            <span>Lines: <b id="finalLines">0</b></span>
          </div>
          <p style="text-align:center;margin:6px 0 10px;color:rgba(233,238,255,.85)">
            Game Over ‚Äî Press <b>Enter</b> to restart.
          </p>

          <div class="leader">
            <h4>Top 10 Leaderboard</h4>
            <ol id="leaderList"></ol>
          </div>

          <div style="display:flex;justify-content:center;gap:10px;margin-top:12px;flex-wrap:wrap">
            <button class="btn" id="restartBtn">Restart</button>
            <button class="btn" id="replayBtn2">Watch replay</button>
            <button class="toggle" id="clearLeaderboardBtn">Clear leaderboard</button>
          </div>
        </div>
      </div>
    </div>

    <div class="card side">
      <div class="hud">
        <div class="titleRow">
          <div class="logo">
            <div class="badge" aria-hidden="true">
              <svg width="22" height="22" viewBox="0 0 24 24" fill="none">
                <path d="M4 6h6v6H4V6Zm10 0h6v6h-6V6ZM4 16h6v6H4v-6Zm10 4h6v2h-6v-2Zm0-4h2v2h-2v-2Zm4 0h2v2h-2v-2Z"
                      stroke="rgba(255,255,255,.85)" stroke-width="1.5" stroke-linejoin="round"/>
              </svg>
            </div>
            <div>
              <h1>Polished Tetris</h1>
              <div class="sub">Trainer hints ‚Ä¢ target outline ‚Ä¢ replay ‚Ä¢ analytics ‚Ä¢ keybinds ‚Ä¢ controller</div>
            </div>
          </div>
          <div class="pill"><span>‚è∏</span><b id="pauseLabel">Running</b></div>
        </div>

        <div class="stats">
          <div class="stat"><div class="k">Score <span>‚ú®</span></div><div class="v" id="score">0</div></div>
          <div class="stat"><div class="k">High <span>üèÜ</span></div><div class="v" id="high">0</div></div>
          <div class="stat"><div class="k">Level <span>‚ö°</span></div><div class="v" id="level">1</div></div>
          <div class="stat"><div class="k">Lines <span>üßπ</span></div><div class="v" id="lines">0</div></div>

          <div class="stat"><div class="k">PPS <span>üìà</span></div><div class="v" id="pps">0.00</div></div>
          <div class="stat"><div class="k">APM <span>‚å®Ô∏è</span></div><div class="v" id="apm">0</div></div>

          <div class="stat full">
            <div class="k">Trainer Step <span>üß©</span></div>
            <div class="v" id="stepInfo">‚Äî</div>
            <div class="subv">
              <span>Misses: <b id="stepMisses">0</b></span>
              <span>Mode: <b id="stepMode">Assist</b></span>
            </div>
          </div>

          <div class="stat full">
            <div class="k">Last Clear <span>üì£</span></div>
            <div class="v" id="lastClear">‚Äî</div>
          </div>

          <div class="stat full">
            <div class="k">Finesse (true path) <span>üß†</span></div>
            <div class="v" id="finEff">100%</div>
            <div class="subv">
              <span>Pieces: <b id="finPieces">0</b></span>
              <span>Errors: <b id="finErrors">0</b></span>
              <span>Last: <b id="finLast">‚Äî</b></span>
            </div>
          </div>

          <div class="stat full">
            <div class="k">Inputs (histogram) <span>üìä</span></div>
            <div class="subv" id="hist">‚Äî</div>
          </div>

          <div class="stat full">
            <div class="k">Finesse by piece <span>üß©</span></div>
            <div class="subv" id="finByPiece">‚Äî</div>
          </div>
        </div>

        <div class="panel">
          <h3>
            Previews & Trainer
            <div class="row">
              <button class="toggle" id="trainerToggle">üéØ Trainer: Off</button>
              <button class="toggle on" id="hintToggle">üí° Hints: On</button>
              <button class="toggle on" id="outlineToggle">üü¶ Target outline: On</button>
              <button class="toggle" id="strictToggle">‚ö† Strict: Off</button>
              <button class="toggle on" id="soundToggle">üîä Sound: On</button>
            </div>
          </h3>

          <div class="miniRow">
            <div class="miniBox">
              <div class="miniLabel"><span>Hold</span><span style="opacity:.8">C / 2-finger tap / Pad X</span></div>
              <canvas class="miniCanvas" id="holdCanvas" width="170" height="130"></canvas>
            </div>
            <div class="miniBox">
              <div class="miniLabel"><span>Next (8)</span><span style="opacity:.8">Trainer forces steps</span></div>
              <canvas class="miniCanvas" id="nextCanvas" width="170" height="320"></canvas>
            </div>
          </div>

          <div style="margin-top:12px">
            <div class="miniLabel" style="padding:0 2px">
              <span>Target Preview</span>
              <span style="opacity:.8">guide</span>
            </div>
            <canvas class="miniCanvas" id="targetCanvas" width="360" height="170"></canvas>
          </div>

          <div class="row" style="margin-top:10px">
            <select id="presetSelect" title="Opener preset">
              <option value="none">No preset</option>
              <option value="dt">DT Cannon (trainer)</option>
              <option value="tki">TKI (trainer)</option>
              <option value="pc">Perfect Clear (trainer)</option>
            </select>
            <button class="toggle" id="loadPresetBtn">Load</button>
            <button class="toggle" id="resetPresetBtn">Reset</button>
          </div>

          <div class="help" style="margin-top:10px">
            <div><kbd>‚Üê</kbd>/<kbd>‚Üí</kbd> move ‚Ä¢ <kbd>‚Üì</kbd> soft drop ‚Ä¢ <kbd>‚Üë</kbd> rotate</div>
            <div><kbd>Z</kbd> rotate CCW ‚Ä¢ <kbd>Shift</kbd> hard drop ‚Ä¢ <kbd>C</kbd> hold</div>
            <div><kbd>Space</kbd> pause ‚Ä¢ <kbd>Enter</kbd> restart (after game over)</div>
            <div style="margin-top:6px;opacity:.92">Touch: swipe L/R, swipe down, swipe up = hard drop, tap = rotate, 2-finger tap = hold</div>
          </div>
        </div>

        <div class="panel">
          <h3>Settings</h3>
          <div class="settingsGrid">
            <div class="setting">
              <div class="k">DAS <b id="dasVal">140</b></div>
              <input id="dasSlider" type="range" min="60" max="240" step="5" value="140"/>
              <div class="help" style="margin-top:6px">Delay before auto-repeat.</div>
            </div>
            <div class="setting">
              <div class="k">ARR <b id="arrVal">35</b></div>
              <input id="arrSlider" type="range" min="0" max="80" step="5" value="35"/>
              <div class="help" style="margin-top:6px">Repeat rate (0 = instant).</div>
            </div>
            <div class="setting">
              <div class="k">Gravity</div>
              <select id="gravitySelect" style="width:100%">
                <option value="modern" selected>Modern</option>
                <option value="classic">Classic</option>
                <option value="zen">Zen</option>
              </select>
              <div class="help" style="margin-top:6px">Speed curve style.</div>
            </div>
            <div class="setting">
              <div class="k">Visual</div>
              <div class="row">
                <button class="toggle on" id="ghostToggle">üëª Ghost: On</button>
                <button class="toggle on" id="fxToggle">‚ú® FX: On</button>
                <button class="toggle on" id="shakeToggle">ü´® Shake: On</button>
              </div>
              <div class="help" style="margin-top:6px">Toggle polish features.</div>
            </div>
          </div>
        </div>

        <div class="panel">
          <h3>
            Keybinds & Controller
            <div class="row">
              <button class="toggle" id="resetBindsBtn">Reset binds</button>
            </div>
          </h3>
          <div class="bindGrid" id="bindGrid"></div>
          <div class="help" style="margin-top:10px">
            Click a key to rebind. Press <kbd>Esc</kbd> to cancel. Controller: D-pad + A rotate, B CCW, Y hard drop, X hold, Start pause.
          </div>
        </div>

        <div class="footerRow">
          <span id="padStatus">üéÆ Gamepad: Not connected</span>
          <div style="display:flex;gap:10px;align-items:center;flex-wrap:wrap">
            <button class="btn" id="pauseBtn">Pause</button>
            <button class="btn" id="replayBtn" disabled>Replay</button>
          </div>
        </div>
      </div>
    </div>
  </div>

<script>
(() => {
  // ------------------ Constants ------------------
  const COLS = 10, ROWS = 20, HIDDEN_ROWS = 2, TOTAL_ROWS = ROWS + HIDDEN_ROWS;

  // ------------------ DOM ------------------
  const gameCanvas = document.getElementById('game');
  const ctx = gameCanvas.getContext('2d');

  const nextCanvas = document.getElementById('nextCanvas');
  const nctx = nextCanvas.getContext('2d');

  const holdCanvas = document.getElementById('holdCanvas');
  const hctx = holdCanvas.getContext('2d');

  const targetCanvas = document.getElementById('targetCanvas');
  const tctx = targetCanvas.getContext('2d');

  const elScore = document.getElementById('score');
  const elHigh  = document.getElementById('high');
  const elLevel = document.getElementById('level');
  const elLines = document.getElementById('lines');
  const elLast  = document.getElementById('lastClear');

  const elStepInfo = document.getElementById('stepInfo');
  const elStepMisses = document.getElementById('stepMisses');
  const elStepMode = document.getElementById('stepMode');

  const elFinEff = document.getElementById('finEff');
  const elFinPieces = document.getElementById('finPieces');
  const elFinErrors = document.getElementById('finErrors');
  const elFinLast = document.getElementById('finLast');

  const elPPS = document.getElementById('pps');
  const elAPM = document.getElementById('apm');
  const elHist = document.getElementById('hist');
  const elFinByPiece = document.getElementById('finByPiece');

  const pauseBtn = document.getElementById('pauseBtn');
  const pauseLabel = document.getElementById('pauseLabel');

  const overlayGameOver = document.getElementById('overlayGameOver');
  const finalScore = document.getElementById('finalScore');
  const finalHigh = document.getElementById('finalHigh');
  const finalLevel = document.getElementById('finalLevel');
  const finalLines = document.getElementById('finalLines');

  const restartBtn = document.getElementById('restartBtn');
  const replayBtn2 = document.getElementById('replayBtn2');
  const replayBtn = document.getElementById('replayBtn');
  const leaderList = document.getElementById('leaderList');
  const clearLeaderboardBtn = document.getElementById('clearLeaderboardBtn');

  const toast = document.getElementById('toast');
  const toastText = document.getElementById('toastText');

  const soundToggle = document.getElementById('soundToggle');

  const trainerToggle = document.getElementById('trainerToggle');
  const hintToggle = document.getElementById('hintToggle');
  const outlineToggle = document.getElementById('outlineToggle');
  const strictToggle = document.getElementById('strictToggle');
  const presetSelect = document.getElementById('presetSelect');
  const loadPresetBtn = document.getElementById('loadPresetBtn');
  const resetPresetBtn = document.getElementById('resetPresetBtn');

  const dasSlider = document.getElementById('dasSlider');
  const arrSlider = document.getElementById('arrSlider');
  const dasVal = document.getElementById('dasVal');
  const arrVal = document.getElementById('arrVal');
  const gravitySelect = document.getElementById('gravitySelect');

  const ghostToggle = document.getElementById('ghostToggle');
  const fxToggle = document.getElementById('fxToggle');
  const shakeToggle = document.getElementById('shakeToggle');

  const padStatus = document.getElementById('padStatus');

  const bindGrid = document.getElementById('bindGrid');
  const resetBindsBtn = document.getElementById('resetBindsBtn');

  // ------------------ Settings (runtime) ------------------
  let DAS = 140;
  let ARR = 35;
  const SOFT_DROP_RATE = 28;
  const LOCK_DELAY = 450;
  const CLEAR_ANIM_MS = 260;
  const PARTICLES_PER_CELL = 6;

  let showGhost = true;
  let enableFX = true;
  let enableShake = true;

  let gravityMode = "modern"; // modern / classic / zen

  // Trainer options
  let trainerOn = false;
  let hintsOn = true;
  let outlineOn = true;
  let strictMode = false;

  // Replay
  const LAST_REPLAY_KEY = "tetris_last_replay_v1";
  let lastReplay = null;
  let replayMode = false;
  let replayIdx = 0;
  let replayStartPerf = 0;

  // Analytics / recording
  let runStartPerf = 0;
  let piecesLocked = 0;
  let actionLog = [];              // [{t, kind:"down"/"up"/"tap", action, data?}]
  let actionCounts = {};           // action -> count
  let actionTotal = 0;

  // Finesse by piece breakdown
  const finByPiece = {I:{ok:0,err:0},O:{ok:0,err:0},T:{ok:0,err:0},S:{ok:0,err:0},Z:{ok:0,err:0},J:{ok:0,err:0},L:{ok:0,err:0}};

  // ------------------ Scoring ------------------
  const LINE_SCORE = {1:100,2:300,3:500,4:800};
  const TSPIN_SCORE = {
    mini: {0:100,1:200,2:400},
    full: {0:400,1:800,2:1200,3:1600}
  };
  const B2B_MULT = 1.5;
  const COMBO_BONUS = 50;
  const LINES_PER_LEVEL = 10;
  const PC_BONUS = {1:800,2:1200,3:1800,4:2000};

  // ------------------ Storage keys ------------------
  const HIGH_KEY = "tetris_highscore_modern_trainer_v3";
  const LEADER_KEY = "tetris_leaderboard_modern_trainer_v3";
  const BIND_KEY = "tetris_keybinds_v3";

  // ------------------ Pieces ------------------
  const PIECES = ['I','O','T','S','Z','J','L'];

  const SHAPES = {
    I: [
      [{x:0,y:1},{x:1,y:1},{x:2,y:1},{x:3,y:1}],
      [{x:2,y:0},{x:2,y:1},{x:2,y:2},{x:2,y:3}],
      [{x:0,y:2},{x:1,y:2},{x:2,y:2},{x:3,y:2}],
      [{x:1,y:0},{x:1,y:1},{x:1,y:2},{x:1,y:3}],
    ],
    O: [
      [{x:1,y:1},{x:2,y:1},{x:1,y:2},{x:2,y:2}],
      [{x:1,y:1},{x:2,y:1},{x:1,y:2},{x:2,y:2}],
      [{x:1,y:1},{x:2,y:1},{x:1,y:2},{x:2,y:2}],
      [{x:1,y:1},{x:2,y:1},{x:1,y:2},{x:2,y:2}],
    ],
    T: [
      [{x:1,y:1},{x:0,y:2},{x:1,y:2},{x:2,y:2}],
      [{x:1,y:1},{x:1,y:2},{x:2,y:2},{x:1,y:3}],
      [{x:0,y:2},{x:1,y:2},{x:2,y:2},{x:1,y:3}],
      [{x:1,y:1},{x:0,y:2},{x:1,y:2},{x:1,y:3}],
    ],
    S: [
      [{x:1,y:1},{x:2,y:1},{x:0,y:2},{x:1,y:2}],
      [{x:1,y:1},{x:1,y:2},{x:2,y:2},{x:2,y:3}],
      [{x:1,y:2},{x:2,y:2},{x:0,y:3},{x:1,y:3}],
      [{x:0,y:1},{x:0,y:2},{x:1,y:2},{x:1,y:3}],
    ],
    Z: [
      [{x:0,y:1},{x:1,y:1},{x:1,y:2},{x:2,y:2}],
      [{x:2,y:1},{x:1,y:2},{x:2,y:2},{x:1,y:3}],
      [{x:0,y:2},{x:1,y:2},{x:1,y:3},{x:2,y:3}],
      [{x:1,y:1},{x:0,y:2},{x:1,y:2},{x:0,y:3}],
    ],
    J: [
      [{x:0,y:1},{x:0,y:2},{x:1,y:2},{x:2,y:2}],
      [{x:1,y:1},{x:2,y:1},{x:1,y:2},{x:1,y:3}],
      [{x:0,y:2},{x:1,y:2},{x:2,y:2},{x:2,y:3}],
      [{x:1,y:1},{x:1,y:2},{x:0,y:3},{x:1,y:3}],
    ],
    L: [
      [{x:2,y:1},{x:0,y:2},{x:1,y:2},{x:2,y:2}],
      [{x:1,y:1},{x:1,y:2},{x:1,y:3},{x:2,y:3}],
      [{x:0,y:2},{x:1,y:2},{x:2,y:2},{x:0,y:3}],
      [{x:0,y:1},{x:1,y:1},{x:1,y:2},{x:1,y:3}],
    ]
  };

  const KICKS_JLSTZ = {
    "0>1": [{x:0,y:0},{x:-1,y:0},{x:-1,y:1},{x:0,y:-2},{x:-1,y:-2}],
    "1>2": [{x:0,y:0},{x:1,y:0},{x:1,y:-1},{x:0,y:2},{x:1,y:2}],
    "2>3": [{x:0,y:0},{x:1,y:0},{x:1,y:1},{x:0,y:-2},{x:1,y:-2}],
    "3>0": [{x:0,y:0},{x:-1,y:0},{x:-1,y:-1},{x:0,y:2},{x:-1,y:2}],
    "1>0": [{x:0,y:0},{x:1,y:0},{x:1,y:1},{x:0,y:-2},{x:1,y:-2}],
    "2>1": [{x:0,y:0},{x:-1,y:0},{x:-1,y:-1},{x:0,y:2},{x:-1,y:2}],
    "3>2": [{x:0,y:0},{x:-1,y:0},{x:-1,y:1},{x:0,y:-2},{x:-1,y:-2}],
    "0>3": [{x:0,y:0},{x:1,y:0},{x:1,y:-1},{x:0,y:2},{x:1,y:2}],
  };

  const KICKS_I = {
    "0>1": [{x:0,y:0},{x:-2,y:0},{x:1,y:0},{x:-2,y:-1},{x:1,y:2}],
    "1>2": [{x:0,y:0},{x:-1,y:0},{x:2,y:0},{x:-1,y:2},{x:2,y:-1}],
    "2>3": [{x:0,y:0},{x:2,y:0},{x:-1,y:0},{x:2,y:1},{x:-1,y:-2}],
    "3>0": [{x:0,y:0},{x:1,y:0},{x:-2,y:0},{x:1,y:-2},{x:-2,y:1}],
    "1>0": [{x:0,y:0},{x:2,y:0},{x:-1,y:0},{x:2,y:1},{x:-1,y:-2}],
    "2>1": [{x:0,y:0},{x:1,y:0},{x:-2,y:0},{x:1,y:-2},{x:-2,y:1}],
    "3>2": [{x:0,y:0},{x:-2,y:0},{x:1,y:0},{x:-2,y:-1},{x:1,y:2}],
    "0>3": [{x:0,y:0},{x:-1,y:0},{x:2,y:0},{x:-1,y:2},{x:2,y:-1}],
  };

  const PIECE_GRADS = {
    I: ["#46f7ff","#1a7cff","#6fffff"],
    O: ["#ffe86b","#ff9b2f","#fff2a3"],
    T: ["#d88cff","#8b4bff","#f2b2ff"],
    S: ["#5affb2","#1ddf77","#b7ffe0"],
    Z: ["#ff6b8a","#ff2f5c","#ffb3c3"],
    J: ["#6aa8ff","#2c5bff","#b7d5ff"],
    L: ["#ffb85a","#ff6a2f","#ffe0b0"],
  };

  // ------------------ PRNG for deterministic bag (replay) ------------------
  let bagSeed = 0;
  function mulberry32(seed){
    let a = seed >>> 0;
    return function() {
      a |= 0; a = a + 0x6D2B79F5 | 0;
      let t = Math.imul(a ^ a >>> 15, 1 | a);
      t = t + Math.imul(t ^ t >>> 7, 61 | t) ^ t;
      return ((t ^ t >>> 14) >>> 0) / 4294967296;
    };
  }
  let bagRand = () => Math.random();
  function setBagSeed(seed){
    bagSeed = seed >>> 0;
    bagRand = mulberry32(bagSeed);
  }
  function randomSeed(){
    const a = (crypto?.getRandomValues ? crypto.getRandomValues(new Uint32Array(1))[0] : (Math.random()*2**32)>>>0);
    return a >>> 0;
  }

  // ------------------ Audio ------------------
  let audioCtx = null;
  let masterGain = null;
  let soundEnabled = true;

  function ensureAudio(){
    if (!soundEnabled) return;
    if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    if (!masterGain){
      masterGain = audioCtx.createGain();
      masterGain.gain.value = 0.6;
      masterGain.connect(audioCtx.destination);
    }
    if (audioCtx.state === "suspended") audioCtx.resume().catch(()=>{});
  }

  function beep(freq=440, dur=0.06, type="sine", gain=0.06, glideTo=null){
    if (!soundEnabled) return;
    ensureAudio();
    if (!audioCtx || !masterGain) return;
    const t0 = audioCtx.currentTime;
    const osc = audioCtx.createOscillator();
    const g = audioCtx.createGain();
    osc.type = type;
    osc.frequency.setValueAtTime(freq, t0);
    if (glideTo) osc.frequency.exponentialRampToValueAtTime(glideTo, t0 + dur);
    g.gain.setValueAtTime(0.0001, t0);
    g.gain.exponentialRampToValueAtTime(gain, t0 + 0.01);
    g.gain.exponentialRampToValueAtTime(0.0001, t0 + dur);
    osc.connect(g); g.connect(masterGain);
    osc.start(t0);
    osc.stop(t0 + dur + 0.02);
  }

  const SFX = {
    move:   ()=>beep(520, 0.035, "triangle", 0.035, 460),
    rotate: ()=>beep(740, 0.045, "square",   0.030, 920),
    drop:   ()=>beep(320, 0.060, "sine",     0.045, 180),
    lock:   ()=>beep(180, 0.055, "sine",     0.050, 120),
    clear:  (n)=>beep(520 + n*120, 0.12, "triangle", 0.060, 980 + n*160),
    hold:   ()=>beep(420, 0.065, "triangle", 0.040, 560),
    over:   ()=>beep(180, 0.22, "sawtooth",  0.055, 80),
    pause:  ()=>beep(260, 0.08, "sine", 0.040, 180),
    level:  ()=>beep(640, 0.12, "triangle", 0.045, 980),
    perfect:()=>beep(920, 0.18, "triangle", 0.070, 1480),
    stepOk: ()=>beep(880, 0.08, "triangle", 0.050, 1100),
    stepBad:()=>beep(220, 0.12, "sawtooth", 0.040, 140),
  };

  function setSoundUI(){
    soundToggle.textContent = soundEnabled ? "üîä Sound: On" : "üîá Sound: Off";
  }

  // ------------------ Helpers ------------------
  const clamp = (v,min,max)=>Math.max(min,Math.min(max,v));
  const lerp = (a,b,t)=>a+(b-a)*t;

  function setToast(text, on){
    toastText.textContent = text;
    toast.classList.toggle('show', !!on);
  }
  function setLastClear(text, alsoToast=false){
    elLast.textContent = text;
    if (alsoToast){
      setToast(text, true);
      setTimeout(()=>setToast("", false), 750);
    }
  }

  // ------------------ Board metrics ------------------
  const cellSize = Math.floor(gameCanvas.width / COLS);
  const boardW = cellSize * COLS;
  const boardH = cellSize * ROWS;
  const padX = Math.floor((gameCanvas.width - boardW)/2);
  const padY = Math.floor((gameCanvas.height - boardH)/2);

  // ------------------ Game state ------------------
  let board;
  let score = 0, lines = 0, level = 1;
  let highScore = 0;
  let leaderboard = [];

  let paused = false, gameOver = false;
  let dropInterval = 900, dropAcc = 0;
  let lastTime = 0;

  let current = null;

  // Bag / queue
  let bag = [];
  let nextQueue = [];
  const NEXT_SHOW = 8;

  // Hold
  let holdType = null;
  let canHold = true;

  // Lock / clear
  let touchingGround = false, groundSince = 0;
  let clearing = false, clearRows = [], clearAnimT = 0;

  // Combo/B2B
  let b2b = false;
  let combo = 0;

  // T-spin detect
  let lastAction = "none";
  let lastRotation = null;

  // Particles + lock flashes
  const particles = [];
  const lockFlashes = [];
  const LOCK_FLASH_MS = 140;

  // Shake / banner
  let shakeTime = 0, shakeDur = 0, shakeMag = 0;
  let levelBannerT = 0;
  let levelBannerText = "";

  // Input / repeats (keyboard)
  let kbMoveHeldDir = 0;
  let kbMoveHeldSince = 0;
  let kbMoveLastRepeat = 0;
  let kbSoftDropHeld = false;

  // Input / repeats (gamepad)
  let gpMoveDir = 0;
  let gpMoveHeldSince = 0;
  let gpMoveLastRepeat = 0;
  let gpSoftDropHeld = false;
  let gpPrevButtons = [];
  let gpIndex = null;

  // Soft drop merged
  let softDropHeld = false;
  let softDropAcc = 0;

  // Perfect clear pending
  let pendingClearInfo = null;

  // Trainer (step script)
  let activePreset = "none";
  let trainerSteps = [];
  let trainerStepIndex = 0;
  let trainerMisses = 0;
  let trainerTarget = null;

  // Hint state
  let hintState = null;

  // Finesse tracking (true path)
  let finessePieces = 0;
  let finesseErrors = 0;
  let finesseOptimalTotal = 0;
  let finesseActualTotal = 0;
  let finesseLastText = "‚Äî";

  // Per-piece input counters + spawn state
  let pieceInputs = null;

  // ------------------ Keybinds ------------------
  const ACTIONS = [
    {id:"moveLeft",   name:"Move Left"},
    {id:"moveRight",  name:"Move Right"},
    {id:"softDrop",   name:"Soft Drop"},
    {id:"rotateCW",   name:"Rotate CW"},
    {id:"rotateCCW",  name:"Rotate CCW"},
    {id:"hardDrop",   name:"Hard Drop"},
    {id:"hold",       name:"Hold"},
    {id:"pause",      name:"Pause"},
    {id:"restart",    name:"Restart"},
  ];

  const DEFAULT_BINDS = {
    moveLeft:   "ArrowLeft",
    moveRight:  "ArrowRight",
    softDrop:   "ArrowDown",
    rotateCW:   "ArrowUp",
    rotateCCW:  "KeyZ",
    hardDrop:   "ShiftLeft",
    hold:       "KeyC",
    pause:      "Space",
    restart:    "Enter",
  };

  let binds = {...DEFAULT_BINDS};
  let bindListening = null;

  function loadBinds(){
    try{
      const raw = localStorage.getItem(BIND_KEY);
      if (!raw) return;
      const obj = JSON.parse(raw);
      if (obj && typeof obj === "object") binds = {...DEFAULT_BINDS, ...obj};
    }catch{}
  }
  function saveBinds(){ try{ localStorage.setItem(BIND_KEY, JSON.stringify(binds)); }catch{} }

  function prettyKey(code){
    const map = {
      ArrowLeft:"‚Üê", ArrowRight:"‚Üí", ArrowUp:"‚Üë", ArrowDown:"‚Üì",
      Space:"Space", Enter:"Enter",
      ShiftLeft:"Shift", ShiftRight:"Shift",
      ControlLeft:"Ctrl", ControlRight:"Ctrl",
      AltLeft:"Alt", AltRight:"Alt",
      Escape:"Esc"
    };
    if (map[code]) return map[code];
    if (code.startsWith("Key")) return code.slice(3);
    if (code.startsWith("Digit")) return code.slice(5);
    return code;
  }

  function renderBindUI(){
    bindGrid.innerHTML = "";
    for (const a of ACTIONS){
      const row = document.createElement("div");
      row.className = "bindRow";
      const k = document.createElement("div");
      k.className = "k";
      k.textContent = a.name;

      const key = document.createElement("div");
      key.className = "bindKey";
      key.textContent = prettyKey(binds[a.id] || "");
      key.title = "Click to rebind";
      key.addEventListener("click", ()=>{
        if (bindListening) return;
        bindListening = a.id;
        key.classList.add("listening");
        setToast(`Press a key for: ${a.name} (Esc to cancel)`, true);
      });

      row.appendChild(k);
      row.appendChild(key);
      bindGrid.appendChild(row);
    }
  }

  function actionForCode(code){
    const matches = [];
    for (const a of ACTIONS){
      const b = binds[a.id];
      if (b === code) matches.push(a.id);
      if (a.id === "hardDrop" && (b === "ShiftLeft" || b === "ShiftRight")){
        if (code === "ShiftLeft" || code === "ShiftRight") matches.push("hardDrop");
      }
    }
    return matches;
  }

  // ------------------ Presets ------------------
  function makePreviewStack(rows, type){
    const blocks = [];
    const alpha = 0.32;
    for (let y=0; y<rows.length; y++){
      for (let x=0; x<rows[y].length; x++){
        if (rows[y][x] === "X") blocks.push({x,y,type,alpha});
      }
    }
    return blocks;
  }

  const PRESETS = {
    none: {
      title: "No preset",
      steps: [],
      target: { title:"No target", blocks: [] }
    },
    dt: {
      title: "DT Cannon (trainer)",
      steps: [
        {type:"L", rot:0, x:2, label:"Build left base"},
        {type:"J", rot:0, x:6, label:"Build right base"},
        {type:"S", rot:0, x:3, label:"Bridge center"},
        {type:"Z", rot:0, x:4, label:"Bridge center"},
        {type:"O", rot:0, x:0, label:"Fill left"},
        {type:"T", rot:0, x:4, label:"Prepare T-slot"},
        {type:"I", rot:1, x:9, label:"Make well / stabilize"},
        {type:"T", rot:1, x:4, label:"DT-style T placement"},
      ],
      target: {
        title: "Aim: DT-style T setup + well",
        blocks: makePreviewStack([
          "..........","..........","..........","..........","..........",
          "..........","..........","..........","..........","..........",
          "..........","..........","..........",
          "...XX.XX...",
          "..XXX.XX...",
          "..XXX.XX...",
          ".XXXX.XX...",
          ".XXXX.XX...",
          ".XXXX.XX...",
          ".XXXX.XX...",
        ], "T")
      }
    },
    tki: {
      title: "TKI (trainer)",
      steps: [
        {type:"L", rot:0, x:6, label:"Start platform"},
        {type:"J", rot:0, x:2, label:"Balance left"},
        {type:"T", rot:0, x:4, label:"Place T center"},
        {type:"S", rot:0, x:3, label:"Shape support"},
        {type:"Z", rot:0, x:4, label:"Shape support"},
        {type:"O", rot:0, x:0, label:"Fill left"},
        {type:"I", rot:1, x:9, label:"Create right well"},
        {type:"T", rot:1, x:4, label:"TKI T-slot feel"},
      ],
      target: {
        title: "Aim: platform + T-slot feel",
        blocks: makePreviewStack([
          "..........","..........","..........","..........","..........",
          "..........","..........","..........","..........","..........",
          "..........","..........","..........",
          "..XXX.....",
          ".XXXX.....",
          ".XX.X.....",
          ".XXXX.....",
          ".XXXX.....",
          ".XXXX.....",
          ".XXXX.....",
        ], "T")
      }
    },
    pc: {
      title: "Perfect Clear (trainer)",
      steps: [
        {type:"Z", rot:0, x:3, label:"Shape 1"},
        {type:"S", rot:0, x:4, label:"Shape 2"},
        {type:"O", rot:0, x:0, label:"Fill left"},
        {type:"I", rot:0, x:3, label:"Flatten"},
        {type:"T", rot:0, x:4, label:"Fill middle"},
        {type:"L", rot:0, x:7, label:"Right shape"},
        {type:"J", rot:0, x:6, label:"Right shape"},
        {type:"I", rot:1, x:9, label:"Finish / clean"},
      ],
      target: {
        title: "Aim: clean 4-line base",
        blocks: makePreviewStack([
          "..........","..........","..........","..........","..........",
          "..........","..........","..........","..........","..........",
          "..........","..........","..........","..........","..........",
          "..........","..........","..........",
          "XXXXXXXX..",
          "XXXXXXXX..",
        ], "O")
      }
    }
  };

  // ------------------ Board helpers ------------------
  function makeBoard(){
    const b = [];
    for (let y=0; y<TOTAL_ROWS; y++) b.push(new Array(COLS).fill(null));
    return b;
  }

  function refillBag(){
    const arr = PIECES.slice();
    for (let i=arr.length-1; i>0; i--){
      const j = (bagRand()*(i+1))|0;
      [arr[i], arr[j]] = [arr[j], arr[i]];
    }
    // store as stack (pop)
    for (const t of arr) bag.push(t);
  }

  function nextFromBag(){
    if (bag.length === 0) refillBag();
    return { type: bag.pop() };
  }

  function nextPieceObject(){
    if (trainerOn && activePreset !== "none" && trainerStepIndex < trainerSteps.length){
      return { type: trainerSteps[trainerStepIndex].type };
    }
    return nextFromBag();
  }

  function ensureQueue(){
    while (nextQueue.length < NEXT_SHOW) nextQueue.push(nextPieceObject());
  }

  function spawnPiece(type){
    return { type, rot:0, x:3, y:0, rx:3, ry:0, rrot:0, lockPulse:0 };
  }

  function getBlocksFor(type, rot, x, y){
    const shape = SHAPES[type][((rot%4)+4)%4];
    return shape.map(p => ({x:p.x+x, y:p.y+y}));
  }

  function getBlocks(piece, rotOverride=null, posOverride=null){
    const rot = rotOverride ?? piece.rot;
    const px = posOverride?.x ?? piece.x;
    const py = posOverride?.y ?? piece.y;
    return getBlocksFor(piece.type, rot, px, py);
  }

  function isInside(x,y){ return x>=0 && x<COLS && y<TOTAL_ROWS; }

  function collidesAt(type, rot, x, y){
    const blocks = getBlocksFor(type, rot, x, y);
    for (const b of blocks){
      if (!isInside(b.x,b.y)) return true;
      if (b.y >= 0 && board[b.y][b.x]) return true;
    }
    return false;
  }

  function collides(piece, rotOverride=null, posOverride=null){
    const rot = rotOverride ?? piece.rot;
    const px = posOverride?.x ?? piece.x;
    const py = posOverride?.y ?? piece.y;
    return collidesAt(piece.type, rot, px, py);
  }

  function recalcSpeed(){
    if (gravityMode === "zen"){ dropInterval = 650; return; }
    if (gravityMode === "classic"){
      const base = 1000;
      dropInterval = clamp(base * Math.pow(0.86, level-1), 70, 1000);
      return;
    }
    const base = 920;
    const lvlFactor = Math.pow(0.90, level-1);
    const scoreFactor = Math.pow(0.995, Math.floor(score/100));
    dropInterval = clamp(base * lvlFactor * scoreFactor, 85, 1000);
  }

  function startShake(mag=6, dur=120){
    if (!enableShake) return;
    shakeMag = mag; shakeDur = dur; shakeTime = dur;
  }

  function showLevelBanner(newLevel){
    levelBannerText = `LEVEL ${newLevel}!`;
    levelBannerT = 900;
    SFX.level();
  }

  // ------------------ Leaderboard ------------------
  function loadHighAndLeaderboard(){
    try{ highScore = parseInt(localStorage.getItem(HIGH_KEY) || "0", 10) || 0; }catch{ highScore = 0; }
    try{
      const raw = localStorage.getItem(LEADER_KEY);
      leaderboard = raw ? JSON.parse(raw) : [];
      if (!Array.isArray(leaderboard)) leaderboard = [];
    }catch{ leaderboard = []; }
  }

  function saveHighAndLeaderboard(){
    try{ localStorage.setItem(HIGH_KEY, String(highScore)); }catch{}
    try{ localStorage.setItem(LEADER_KEY, JSON.stringify(leaderboard)); }catch{}
  }

  function formatDate(ts){
    const d = new Date(ts);
    const pad = (n)=>String(n).padStart(2,"0");
    return `${d.getFullYear()}-${pad(d.getMonth()+1)}-${pad(d.getDate())} ${pad(d.getHours())}:${pad(d.getMinutes())}`;
  }

  function updateLeaderboardUI(){
    leaderList.innerHTML = "";
    if (!leaderboard.length){
      const li = document.createElement("li");
      li.innerHTML = `<small>No runs yet ‚Äî you‚Äôll be #1 üòâ</small>`;
      leaderList.appendChild(li);
      return;
    }
    leaderboard.forEach((r)=>{
      const li = document.createElement("li");
      li.innerHTML = `<b>${r.score}</b> <small>(L${r.level} ‚Ä¢ ${r.lines} lines ‚Ä¢ ${formatDate(r.ts)})</small>`;
      leaderList.appendChild(li);
    });
  }

  function saveLastReplay(){
    try{ localStorage.setItem(LAST_REPLAY_KEY, JSON.stringify(lastReplay)); }catch{}
    replayBtn.disabled = !lastReplay;
    replayBtn2.disabled = !lastReplay;
  }
  function loadLastReplay(){
    try{
      const raw = localStorage.getItem(LAST_REPLAY_KEY);
      lastReplay = raw ? JSON.parse(raw) : null;
    }catch{ lastReplay = null; }
    replayBtn.disabled = !lastReplay;
    replayBtn2.disabled = !lastReplay;
  }

  function endGame(){
    gameOver = true;
    paused = false;

    if (score > highScore) highScore = score;

    finalScore.textContent = String(score);
    finalHigh.textContent = String(highScore);
    finalLevel.textContent = String(level);
    finalLines.textContent = String(lines);

    overlayGameOver.classList.add('show');
    SFX.over();

    leaderboard.push({ score, level, lines, ts: Date.now() });
    leaderboard.sort((a,b)=>b.score - a.score);
    leaderboard = leaderboard.slice(0, 10);
    saveHighAndLeaderboard();
    updateHud();
    updateLeaderboardUI();

    if (!replayMode){
      lastReplay = {
        seed: bagSeed,
        gravityMode, DAS, ARR,
        trainerOn, hintsOn, outlineOn, strictMode, activePreset,
        actionLog,
      };
      saveLastReplay();
    }
  }

  // ------------------ HUD update ------------------
  function updateTrainerHud(){
    if (!(trainerOn && activePreset !== "none" && trainerSteps.length)){
      elStepInfo.textContent = "‚Äî";
      elStepMisses.textContent = "0";
      elStepMode.textContent = strictMode ? "Strict" : "Assist";
      return;
    }
    const i = Math.min(trainerStepIndex + 1, trainerSteps.length);
    const n = trainerSteps.length;
    const step = trainerSteps[trainerStepIndex] || null;
    const label = step ? step.label : "Done";
    elStepInfo.textContent = `(${i}/${n}) ${label}`;
    elStepMisses.textContent = String(trainerMisses);
    elStepMode.textContent = strictMode ? "Strict" : "Assist";
  }

  function updateAnalyticsHud(){
    const now = performance.now();
    const elapsed = Math.max(0.001, (now - runStartPerf) / 1000);
    const pps = piecesLocked / elapsed;
    const apm = Math.round((actionTotal / elapsed) * 60);

    elPPS.textContent = pps.toFixed(2);
    elAPM.textContent = String(apm);

    const keys = ["moveLeft","moveRight","softDrop","rotateCW","rotateCCW","hardDrop","hold"];
    const parts = keys.map(k=>{
      const v = actionCounts[k] || 0;
      const label = {
        moveLeft:"‚Üê", moveRight:"‚Üí", softDrop:"‚Üì", rotateCW:"‚ü≥", rotateCCW:"‚ü≤", hardDrop:"‚á©", hold:"H"
      }[k];
      return `${label} ${v}`;
    });
    elHist.textContent = parts.join("  ‚Ä¢  ");

    const by = ["I","O","T","S","Z","J","L"].map(t=>{
      const obj = finByPiece[t];
      const total = obj.ok + obj.err;
      if (!total) return `${t}: ‚Äî`;
      const errPct = Math.round((obj.err/total)*100);
      return `${t}: ${errPct}% err`;
    });
    elFinByPiece.textContent = by.join("  ‚Ä¢  ");
  }

  function updateHud(){
    elScore.textContent = String(score);
    elLines.textContent = String(lines);
    elLevel.textContent = String(level);
    elHigh.textContent = String(highScore);

    pauseLabel.textContent = paused ? "Paused" : (replayMode ? "Replay" : "Running");
    pauseBtn.textContent = paused ? "Resume" : "Pause";

    trainerToggle.textContent = trainerOn ? "üéØ Trainer: On" : "üéØ Trainer: Off";
    hintToggle.textContent = hintsOn ? "üí° Hints: On" : "üí° Hints: Off";
    outlineToggle.textContent = outlineOn ? "üü¶ Target outline: On" : "üü¶ Target outline: Off";
    strictToggle.textContent = strictMode ? "‚ö† Strict: On" : "‚ö† Strict: Off";

    trainerToggle.classList.toggle("on", trainerOn);
    hintToggle.classList.toggle("on", hintsOn);
    outlineToggle.classList.toggle("on", outlineOn);
    strictToggle.classList.toggle("on", strictMode);

    dasVal.textContent = String(DAS);
    arrVal.textContent = String(ARR);

    ghostToggle.textContent = showGhost ? "üëª Ghost: On" : "üëª Ghost: Off";
    fxToggle.textContent = enableFX ? "‚ú® FX: On" : "‚ú® FX: Off";
    shakeToggle.textContent = enableShake ? "ü´® Shake: On" : "ü´® Shake: Off";

    ghostToggle.classList.toggle("on", showGhost);
    fxToggle.classList.toggle("on", enableFX);
    shakeToggle.classList.toggle("on", enableShake);

    updateTrainerHud();

    const eff = finesseActualTotal === 0 ? 100 : clamp((finesseOptimalTotal / finesseActualTotal) * 100, 0, 120);
    elFinEff.textContent = `${eff.toFixed(0)}%`;
    elFinPieces.textContent = String(finessePieces);
    elFinErrors.textContent = String(finesseErrors);
    elFinLast.textContent = finesseLastText;

    updateAnalyticsHud();

    replayBtn.disabled = !lastReplay;
    replayBtn2.disabled = !lastReplay;
  }

  // ------------------ Replay ------------------
  function startReplay(){
    if (!lastReplay) return;
    setToast("‚ñ∂ Replaying last run‚Ä¶", true);
    setTimeout(()=>setToast("", false), 900);

    replayMode = true;
    replayIdx = 0;

    gravityMode = lastReplay.gravityMode || "modern";
    DAS = lastReplay.DAS ?? DAS;
    ARR = lastReplay.ARR ?? ARR;

    trainerOn = !!lastReplay.trainerOn;
    hintsOn = !!lastReplay.hintsOn;
    outlineOn = !!lastReplay.outlineOn;
    strictMode = !!lastReplay.strictMode;
    activePreset = lastReplay.activePreset || "none";

    trainerSteps = (PRESETS[activePreset]?.steps || []).slice();
    trainerStepIndex = 0;
    trainerMisses = 0;
    trainerTarget = PRESETS[activePreset]?.target || null;

    setBagSeed(lastReplay.seed || randomSeed());

    resetGame(true);

    actionLog = (lastReplay.actionLog || []).slice();
    actionCounts = {};
    actionTotal = 0;

    replayStartPerf = performance.now();
    paused = false;
    gameOver = false;
    overlayGameOver.classList.remove('show');

    updateHud();
  }

  function stopReplay(){
    replayMode = false;
    setToast("Replay ended", true);
    setTimeout(()=>setToast("", false), 700);
    resetGame(false);
  }

  // ------------------ Pause ------------------
  function togglePause(){
    if (gameOver) return;
    if (replayMode) return;
    paused = !paused;
    updateHud();
    setToast(paused ? "Paused" : "Resumed", true);
    SFX.pause();
    setTimeout(()=>setToast("", false), 700);
  }

  // ------------------ Hold ------------------
  function hold(){
    if (paused || gameOver || clearing) return;
    if (replayMode) return;
    if (!canHold) return;
    canHold = false;
    SFX.hold();

    const curType = current.type;
    if (holdType === null){
      holdType = curType;
      spawnFromQueue();
    } else {
      current = spawnPiece(holdType);
      holdType = curType;
      current.x = 3; current.y = 0; current.rot = 0;
      lastAction = "none";
      lastRotation = null;
      beginPieceInputTracking();
      if (collides(current)) endGame();
    }
    drawHold();
  }

  // ------------------ Movement / rotation (SRS kicks) ------------------
  function tryMove(dx,dy, sfx=true){
    if (paused || gameOver || clearing) return false;
    if (replayMode) return false;
    const nx = current.x + dx;
    const ny = current.y + dy;
    if (!collides(current, current.rot, {x:nx,y:ny})){
      current.x = nx;
      current.y = ny;
      touchingGround = false;

      if (dx !== 0){
        lastAction = "move";
        if (pieceInputs) pieceInputs.moves += Math.abs(dx);
      }
      if (dy !== 0) lastAction = "drop";

      if (sfx && dx !== 0) SFX.move();
      return true;
    }
    return false;
  }

  function rotateWithKick(type, x, y, rot, dir){
    if (type === "O") return {x,y,rot};
    const from = rot;
    const to = (from + (dir>0?1:3)) % 4;
    const key = `${from}>${to}`;
    const kicks = (type === "I") ? KICKS_I[key] : KICKS_JLSTZ[key];
    for (let i=0; i<kicks.length; i++){
      const k = kicks[i];
      const nx = x + k.x;
      const ny = y + k.y;
      if (!collidesAt(type, to, nx, ny)){
        return {x:nx, y:ny, rot:to};
      }
    }
    return null;
  }

  function rotate(dir){
    if (paused || gameOver || clearing) return false;
    if (replayMode) return false;
    const res = rotateWithKick(current.type, current.x, current.y, current.rot, dir);
    if (!res) return false;
    if (current.type === "O") return true;

    current.rot = res.rot;
    current.x = res.x;
    current.y = res.y;

    touchingGround = false;
    lastAction = "rotate";
    lastRotation = { dx:res.x-current.x, dy:res.y-current.y, usedKick:true };

    if (pieceInputs) pieceInputs.rotates += 1;

    SFX.rotate();
    return true;
  }

  function hardDropDistance(piece){
    let d=0;
    while (!collides(piece, piece.rot, {x:piece.x, y:piece.y + d + 1})) d++;
    return d;
  }

  function hardDrop(){
    if (paused || gameOver || clearing) return;
    if (replayMode) return;
    const d = hardDropDistance(current);
    if (d <= 0) return;
    current.y += d;
    score += d * 2;
    updateHud();
    SFX.drop();
    startShake(8, 140);
    touchingGround = true;
    groundSince = LOCK_DELAY + 1;
    lockPiece();
  }

  // ------------------ Trainer hint computation ------------------
  function computeHint(){
    hintState = null;
    if (!(trainerOn && hintsOn && activePreset !== "none" && trainerStepIndex < trainerSteps.length)) return;
    const step = trainerSteps[trainerStepIndex];
    const temp = {type:step.type, rot:step.rot, x:step.x, y:0};
    if (collidesAt(temp.type, temp.rot, temp.x, temp.y)) return;
    const d = hardDropDistance(temp);
    const y = temp.y + d;
    hintState = { type: step.type, x: step.x, rot: step.rot, y, label: step.label, i: trainerStepIndex+1, n: trainerSteps.length };
  }

  function validateStepOnLock(){
    if (!(trainerOn && activePreset !== "none" && trainerStepIndex < trainerSteps.length)) return {active:false};
    const step = trainerSteps[trainerStepIndex];
    const ok = (current.type === step.type && current.x === step.x && (current.rot % 4) === (step.rot % 4));
    return {active:true, ok, step};
  }

  // ------------------ True finesse / analytics tracking ------------------
  function beginPieceInputTracking(){
    pieceInputs = {
      type: current?.type ?? "?",
      spawnedX: current?.x ?? 3,
      spawnedY: current?.y ?? 0,
      spawnedRot: current?.rot ?? 0,
      moves: 0,
      rotates: 0
    };
  }

  // (Simple finesse: compare actions vs heuristic; kept from earlier design)
  function finalizeFinesseForLockedPiece(){
    if (!pieceInputs || !current) return;

    const actual = pieceInputs.moves + pieceInputs.rotates;
    const dx = Math.abs(current.x - pieceInputs.spawnedX);
    const dr = (() => {
      const a = ((current.rot - pieceInputs.spawnedRot) % 4 + 4) % 4;
      const b = ((pieceInputs.spawnedRot - current.rot) % 4 + 4) % 4;
      return Math.min(a,b);
    })();
    const optimal = dx + dr;

    finessePieces += 1;
    finesseOptimalTotal += optimal;
    finesseActualTotal += actual;

    const error = actual > optimal;
    if (error) finesseErrors += 1;

    const bp = finByPiece[pieceInputs.type];
    if (bp){
      if (error) bp.err += 1; else bp.ok += 1;
    }

    finesseLastText = `${pieceInputs.type}: ${actual} vs ${optimal}${error ? " (ERR)" : " (OK)"}`;
    pieceInputs = null;

    updateHud();
  }

  // ------------------ Recording / analytics helpers ------------------
  function countAction(actionId){
    actionCounts[actionId] = (actionCounts[actionId] || 0) + 1;
    actionTotal += 1;
  }

  // ‚úÖ UPDATED: supports extra data (for touch softDropTap etc.)
  function recordAction(kind, actionId, data=null){
    if (replayMode) return;
    const t = performance.now() - runStartPerf;
    actionLog.push({ t, kind, action: actionId, data });
  }

  // ‚úÖ Tap-style actions (used by touch; also works for keyboard if needed)
  function triggerActionTap(actionId, data=null){
    if (bindListening) return;

    if (!replayMode){
      recordAction("tap", actionId, data);

      if (actionId === "softDropTap"){
        const n = Math.max(1, (data?.n|0) || 1);
        for (let i=0;i<n;i++) countAction("softDrop");
      } else if (["moveLeft","moveRight","rotateCW","rotateCCW","hardDrop","hold"].includes(actionId)){
        countAction(actionId);
      }
    }

    handleActionTap(actionId, data);
  }

  function handleActionTap(actionId, data){
    ensureAudio();

    if (paused || gameOver || clearing) return;
    if (replayMode) return;

    switch(actionId){
      case "moveLeft":  tryMove(-1,0,true); break;
      case "moveRight": tryMove(1,0,true); break;
      case "rotateCW":  rotate(+1); break;
      case "rotateCCW": rotate(-1); break;
      case "hardDrop":  hardDrop(); break;
      case "hold":      hold(); break;

      case "softDropTap": {
        const n = Math.max(1, (data?.n|0) || 1);
        for (let i=0;i<n;i++){
          if (!collides(current, current.rot, {x:current.x, y:current.y+1})){
            current.y += 1;
            score += 1;
          } else break;
        }
        updateHud();
        break;
      }
    }
  }

  // ------------------ Unified action triggering (keyboard/controller) ------------------
  function triggerActionDown(actionId, e=null){
    if (bindListening) return;
    if (!replayMode){
      recordAction("down", actionId, null);
      if (["moveLeft","moveRight","softDrop","rotateCW","rotateCCW","hardDrop","hold"].includes(actionId)) countAction(actionId);
    }
    handleActionDown(actionId, e);
  }
  function triggerActionUp(actionId, e=null){
    if (!replayMode) recordAction("up", actionId, null);
    handleActionUp(actionId, e);
  }

  function handleActionDown(actionId, e){
    ensureAudio();

    if (actionId === "pause"){ e?.preventDefault?.(); togglePause(); return; }
    if (actionId === "restart"){
      if (gameOver){
        e?.preventDefault?.();
        if (replayMode) stopReplay();
        else resetGame(false);
      }
      return;
    }
    if (paused || gameOver || clearing) return;
    if (replayMode) return;

    switch(actionId){
      case "hardDrop": e?.preventDefault?.(); hardDrop(); break;
      case "hold": e?.preventDefault?.(); hold(); break;
      case "rotateCCW": e?.preventDefault?.(); rotate(-1); break;
      case "rotateCW": e?.preventDefault?.(); rotate(+1); break;
      case "moveLeft":
        e?.preventDefault?.();
        kbMoveHeldDir = -1;
        kbMoveHeldSince = performance.now();
        kbMoveLastRepeat = 0;
        tryMove(-1,0,true);
        break;
      case "moveRight":
        e?.preventDefault?.();
        kbMoveHeldDir = 1;
        kbMoveHeldSince = performance.now();
        kbMoveLastRepeat = 0;
        tryMove(1,0,true);
        break;
      case "softDrop":
        e?.preventDefault?.();
        kbSoftDropHeld = true;
        break;
    }
  }

  function handleActionUp(actionId, e){
    if (actionId === "moveLeft"){
      if (kbMoveHeldDir === -1) kbMoveHeldDir = 0;
    } else if (actionId === "moveRight"){
      if (kbMoveHeldDir === 1) kbMoveHeldDir = 0;
    } else if (actionId === "softDrop"){
      kbSoftDropHeld = false;
    }
  }

  // ‚úÖ UPDATED: replay understands "tap" events (touch included)
  function applyRecordedAction(ev){
    const prevReplay = replayMode;
    replayMode = true;

    if (ev.kind === "down") handleActionDown(ev.action, null);
    else if (ev.kind === "up") handleActionUp(ev.action, null);
    else if (ev.kind === "tap"){
      // temporarily allow tap execution
      replayMode = false;
      handleActionTap(ev.action, ev.data);
      replayMode = true;
    }

    replayMode = prevReplay;
  }

  // ------------------ Keyboard event plumbing ------------------
  function onKeyDown(e){
    if (bindListening){
      e.preventDefault();
      if (e.code === "Escape"){
        bindListening = null;
        setToast("", false);
        renderBindUI();
        return;
      }
      binds[bindListening] = e.code;
      saveBinds();
      setToast(`Bound ${bindListening} to ${prettyKey(e.code)}`, true);
      setTimeout(()=>setToast("", false), 700);
      bindListening = null;
      renderBindUI();
      return;
    }

    const actions = actionForCode(e.code);
    if (!actions.length) return;
    for (const a of actions) triggerActionDown(a, e);
  }

  function onKeyUp(e){
    if (bindListening) return;
    const actions = actionForCode(e.code);
    if (!actions.length) return;
    for (const a of actions) triggerActionUp(a, e);
  }

  window.addEventListener('keydown', (e)=>{
    const block = ["ArrowLeft","ArrowRight","ArrowUp","ArrowDown","Space"];
    if (block.includes(e.code)) e.preventDefault();
  }, {passive:false});

  document.addEventListener('keydown', onKeyDown, {passive:false});
  document.addEventListener('keyup', onKeyUp, {passive:false});

  // ------------------ Held moves (DAS/ARR) ------------------
  function handleHeldMoves(){
    if (paused || gameOver || clearing) return;
    if (replayMode) return;
    if (kbMoveHeldDir === 0) return;

    const now = performance.now();
    const heldFor = now - kbMoveHeldSince;
    if (heldFor < DAS) return;

    if (ARR === 0){
      while (tryMove(kbMoveHeldDir, 0, false)) {}
      SFX.move();
      kbMoveLastRepeat = now;
      return;
    }

    if (kbMoveLastRepeat === 0 || now - kbMoveLastRepeat >= ARR){
      tryMove(kbMoveHeldDir, 0, true);
      kbMoveLastRepeat = now;
    }
  }
  setInterval(handleHeldMoves, 8);

  // ------------------ Touch (RECORDED + REPLAYED) ------------------
  let touchStart = null;
  let activePointers = new Map();

  function onPointerDown(e){
    if (e.pointerType === "mouse") return;
    ensureAudio();
    gameCanvas.setPointerCapture?.(e.pointerId);
    activePointers.set(e.pointerId, {x:e.clientX, y:e.clientY, t:performance.now()});
    if (activePointers.size === 1){
      touchStart = { x:e.clientX, y:e.clientY, t:performance.now(), moved:false };
    }
  }

  function onPointerMove(e){
    if (!touchStart) return;
    const dx = e.clientX - touchStart.x;
    const dy = e.clientY - touchStart.y;
    const adx = Math.abs(dx), ady = Math.abs(dy);

    if (adx + ady > 6) touchStart.moved = true;

    const TH = 28;
    if (paused || gameOver || clearing) return;
    if (replayMode) return;

    // Vertical swipe
    if (ady > adx && ady > TH){
      if (dy > 0){
        // swipe down = 2-step soft drop tap (recorded)
        triggerActionTap("softDropTap", { n: 2 });
      } else {
        // swipe up = hard drop (recorded)
        triggerActionTap("hardDrop");
      }
      touchStart.x = e.clientX; touchStart.y = e.clientY; touchStart.moved = false;
    }
    // Horizontal swipe
    else if (adx > ady && adx > TH){
      if (dx > 0) triggerActionTap("moveRight");
      else triggerActionTap("moveLeft");
      touchStart.x = e.clientX; touchStart.y = e.clientY; touchStart.moved = false;
    }
  }

  function onPointerUp(e){
    if (e.pointerType === "mouse") return;

    const wasTwoFingerTap = (activePointers.size >= 2);
    activePointers.delete(e.pointerId);

    if (wasTwoFingerTap && activePointers.size === 0){
      // 2-finger tap = hold (recorded)
      triggerActionTap("hold");
      touchStart = null;
      return;
    }
    if (!touchStart) return;

    const dt = performance.now() - touchStart.t;
    if (!touchStart.moved && dt < 260){
      if (!paused && !gameOver && !clearing && !replayMode){
        // tap = rotate (recorded)
        triggerActionTap("rotateCW");
      }
    }
    touchStart = null;
  }

  gameCanvas.addEventListener('pointerdown', onPointerDown, {passive:true});
  gameCanvas.addEventListener('pointermove', onPointerMove, {passive:true});
  gameCanvas.addEventListener('pointerup', onPointerUp, {passive:true});
  gameCanvas.addEventListener('pointercancel', ()=>{ touchStart=null; activePointers.clear(); }, {passive:true});

  // ------------------ Gamepad support (poll) ------------------
  function gamepadName(gp){
    if (!gp) return "";
    return gp.id ? gp.id.split("(")[0].trim() : "Gamepad";
  }

  function pollGamepad(){
    const pads = navigator.getGamepads ? navigator.getGamepads() : [];
    let gp = null;

    if (gpIndex !== null && pads[gpIndex]) gp = pads[gpIndex];
    if (!gp){
      for (let i=0;i<pads.length;i++){
        if (pads[i]){ gp = pads[i]; gpIndex = i; break; }
      }
    }

    padStatus.textContent = gp ? `üéÆ Gamepad: ${gamepadName(gp)} (connected)` : "üéÆ Gamepad: Not connected";
    if (!gp) { gpPrevButtons = []; gpMoveDir = 0; gpSoftDropHeld = false; return; }

    const btn = (i)=> gp.buttons[i]?.pressed;
    const left = !!btn(14);
    const right = !!btn(15);
    const down = !!btn(13);

    const a = !!btn(0);
    const b = !!btn(1);
    const x = !!btn(2);
    const y = !!btn(3);
    const start = !!btn(9);

    const prev = gpPrevButtons;
    const edge = (i, pressed)=> pressed && !prev[i];

    if (edge(9, start)) triggerActionDown("pause", null);

    if (!paused && !gameOver && !replayMode){
      if (edge(0, a)) triggerActionDown("rotateCW", null);
      if (edge(1, b)) triggerActionDown("rotateCCW", null);
      if (edge(2, x)) triggerActionDown("hold", null);
      if (edge(3, y)) triggerActionDown("hardDrop", null);
    }

    gpSoftDropHeld = down && !paused && !gameOver && !replayMode;

    const dir = left && !right ? -1 : right && !left ? 1 : 0;
    if (dir !== gpMoveDir){
      gpMoveDir = dir;
      if (gpMoveDir !== 0 && !paused && !gameOver && !clearing && !replayMode){
        gpMoveHeldSince = performance.now();
        gpMoveLastRepeat = 0;
        triggerActionDown(gpMoveDir === -1 ? "moveLeft" : "moveRight", null);
      }
    } else if (gpMoveDir !== 0 && !paused && !gameOver && !clearing && !replayMode){
      const now = performance.now();
      const heldFor = now - gpMoveHeldSince;
      if (heldFor >= DAS){
        if (ARR === 0){
          while (tryMove(gpMoveDir, 0, false)) {}
          SFX.move();
          gpMoveLastRepeat = now;
        } else {
          if (gpMoveLastRepeat === 0 || now - gpMoveLastRepeat >= ARR){
            tryMove(gpMoveDir, 0, true);
            gpMoveLastRepeat = now;
          }
        }
      }
    }

    gpPrevButtons = gp.buttons.map(b=>!!b.pressed);
  }

  // ------------------ Drawing helpers ------------------
  function drawRoundedRect(c,x,y,w,h,r){
    const rr = Math.min(r, w/2, h/2);
    c.beginPath();
    c.moveTo(x+rr,y);
    c.arcTo(x+w,y,x+w,y+h,rr);
    c.arcTo(x+w,y+h,x,y+h,rr);
    c.arcTo(x,y+h,x,y,rr);
    c.arcTo(x,y,x+w,y,rr);
    c.closePath();
  }

  function pieceGradient(type,x,y,w,h, cctx=ctx){
    const [c1,c2,glow] = PIECE_GRADS[type];
    const g = cctx.createLinearGradient(x,y,x+w,y+h);
    g.addColorStop(0, c1);
    g.addColorStop(1, c2);
    return { fill:g, glow };
  }

  function drawCell(x,y,type, alpha=1, scale=1, flash=0, glowBoost=0){
    const px = padX + x*cellSize;
    const py = padY + y*cellSize;
    const inset = 2.2;
    const w = cellSize - inset*2;
    const h = cellSize - inset*2;

    const cx = px + cellSize/2;
    const cy = py + cellSize/2;
    const sw = w*scale;
    const sh = h*scale;

    const rx = cx - sw/2 + inset;
    const ry = cy - sh/2 + inset;

    const grad = pieceGradient(type, rx, ry, sw, sh);

    ctx.save();
    ctx.globalAlpha = alpha;

    ctx.shadowColor = grad.glow;
    ctx.shadowBlur = 12 + glowBoost;
    drawRoundedRect(ctx, rx, ry, sw, sh, 10);
    ctx.fillStyle = grad.fill;
    ctx.fill();

    ctx.shadowBlur = 0;
    const g2 = ctx.createLinearGradient(rx, ry, rx, ry+sh);
    g2.addColorStop(0, "rgba(255,255,255,.35)");
    g2.addColorStop(0.35, "rgba(255,255,255,.12)");
    g2.addColorStop(1, "rgba(0,0,0,.14)");
    drawRoundedRect(ctx, rx+1.2, ry+1.2, sw-2.4, sh-2.4, 9);
    ctx.fillStyle = g2;
    ctx.fill();

    if (flash > 0){
      ctx.globalAlpha = alpha * flash;
      drawRoundedRect(ctx, rx, ry, sw, sh, 10);
      ctx.fillStyle = "rgba(255,255,255,.78)";
      ctx.fill();
    }

    ctx.globalAlpha = alpha * 0.9;
    ctx.strokeStyle = "rgba(255,255,255,.10)";
    ctx.lineWidth = 1;
    drawRoundedRect(ctx, rx, ry, sw, sh, 10);
    ctx.stroke();

    ctx.restore();
  }

  function drawTargetOutline(blocks, type, pulseT){
    if (!outlineOn) return;
    const [c1,c2,glow] = PIECE_GRADS[type];
    const a = 0.45 + 0.35 * (0.5 + 0.5*Math.sin(pulseT));
    ctx.save();
    ctx.lineWidth = 2;
    ctx.globalAlpha = a;
    ctx.shadowColor = glow;
    ctx.shadowBlur = 14;

    for (const b of blocks){
      const vy = b.y - HIDDEN_ROWS;
      if (vy < 0) continue;
      const px = padX + b.x*cellSize;
      const py = padY + vy*cellSize;
      const inset = 1.3;
      const w = cellSize - inset*2;
      const h = cellSize - inset*2;
      const g = ctx.createLinearGradient(px,py,px+cellSize,py+cellSize);
      g.addColorStop(0,c1);
      g.addColorStop(1,c2);
      ctx.strokeStyle = g;
      drawRoundedRect(ctx, px+inset, py+inset, w, h, 11);
      ctx.stroke();
    }
    ctx.restore();
  }

  function drawGrid(){
    const gx = padX, gy = padY, w = boardW, h = boardH;

    const bg = ctx.createLinearGradient(gx, gy, gx+w, gy+h);
    bg.addColorStop(0, "rgba(21,33,74,.72)");
    bg.addColorStop(1, "rgba(13,22,54,.75)");
    ctx.fillStyle = bg;
    drawRoundedRect(ctx, gx, gy, w, h, 14);
    ctx.fill();

    ctx.save();
    ctx.globalAlpha = 0.85;
    ctx.lineWidth = 1;
    for (let y=0; y<=ROWS; y++){
      const yy = gy + y*cellSize;
      ctx.strokeStyle = (y%2===0) ? "rgba(255,255,255,.04)" : "rgba(255,255,255,.03)";
      ctx.beginPath(); ctx.moveTo(gx,yy); ctx.lineTo(gx+w,yy); ctx.stroke();
    }
    for (let x=0; x<=COLS; x++){
      const xx = gx + x*cellSize;
      ctx.strokeStyle = (x%2===0) ? "rgba(255,255,255,.04)" : "rgba(255,255,255,.03)";
      ctx.beginPath(); ctx.moveTo(xx,gy); ctx.lineTo(xx,gy+h); ctx.stroke();
    }
    ctx.restore();

    ctx.strokeStyle = "rgba(255,255,255,.09)";
    ctx.lineWidth = 1.25;
    drawRoundedRect(ctx, gx, gy, w, h, 14);
    ctx.stroke();
  }

  function drawGhost(){
    if (!showGhost) return;
    if (paused || gameOver || clearing) return;
    const d = hardDropDistance(current);
    const blocks = getBlocks(current, current.rot, {x:current.x, y:current.y + d});
    for (const b of blocks){
      const vy = b.y - HIDDEN_ROWS;
      if (vy < 0) continue;
      drawCell(b.x, vy, current.type, 0.20, 0.98, 0);
    }
  }

  let hintPulse = 0;

  function drawHintGhost(dt){
    if (!hintState) return;
    if (paused || gameOver || clearing) return;

    hintPulse += dt * 0.010;

    const blocks = getBlocksFor(hintState.type, hintState.rot, hintState.x, hintState.y);

    for (const b of blocks){
      const vy = b.y - HIDDEN_ROWS;
      if (vy < 0) continue;
      drawCell(b.x, vy, hintState.type, 0.32, 1.00, 0, 16);
    }

    drawTargetOutline(blocks, hintState.type, hintPulse);

    const gx = padX, gy = padY, w = boardW;
    const text = `Step ${hintState.i}/${hintState.n}: ${hintState.label}`;
    ctx.save();
    ctx.globalAlpha = 0.95;
    ctx.font = "800 12px system-ui, -apple-system, Segoe UI, Roboto, Arial";
    const tw = ctx.measureText(text).width;
    const bx = gx + (w - (tw + 22)) / 2;
    const by = gy + 10;

    ctx.shadowColor = "rgba(120,255,220,.35)";
    ctx.shadowBlur = 18;
    drawRoundedRect(ctx, bx, by, tw+22, 26, 12);
    const g = ctx.createLinearGradient(bx, by, bx+tw+22, by+26);
    g.addColorStop(0, "rgba(120,255,220,.20)");
    g.addColorStop(1, "rgba(160,180,255,.18)");
    ctx.fillStyle = g;
    ctx.fill();
    ctx.shadowBlur = 0;

    ctx.strokeStyle = "rgba(255,255,255,.18)";
    ctx.stroke();

    ctx.fillStyle = "rgba(255,255,255,.92)";
    ctx.textBaseline = "middle";
    ctx.fillText(text, bx+11, by+13);
    ctx.restore();
  }

  let frameDT = 16.67;

  function drawBoardCells(){
    for (let y=HIDDEN_ROWS; y<TOTAL_ROWS; y++){
      for (let x=0; x<COLS; x++){
        const cell = board[y][x];
        if (!cell) continue;

        const vy = y - HIDDEN_ROWS;
        if (vy < 0 || vy >= ROWS) continue;
        drawCell(x, vy, cell.type, 1, 1, 0);
      }
    }
  }

  function lerpAngle(a,b,t){
    let d = (b - a);
    while (d > 2) d -= 4;
    while (d < -2) d += 4;
    return a + d*t;
  }

  function drawCurrentPiece(dt){
    if (!current) return;
    const s = 1 - Math.pow(0.001, dt/16.67);
    current.rx = lerp(current.rx, current.x, s);
    current.ry = lerp(current.ry, current.y, s);
    current.rrot = lerpAngle(current.rrot, current.rot, s);

    const blocks = SHAPES[current.type][current.rot];
    for (const p of blocks){
      const x = p.x + Math.round(current.rx);
      const y = p.y + Math.round(current.ry);
      const vy = y - HIDDEN_ROWS;
      if (vy < 0) continue;
      drawCell(x, vy, current.type, 1, 1, 0);
    }
  }

  function drawParticles(dt){
    if (!enableFX) return;
    for (let i=particles.length-1; i>=0; i--){
      const p = particles[i];
      p.age += dt/1000;
      if (p.age >= p.life){ particles.splice(i,1); continue; }
      p.vy += 520 * (dt/1000);
      p.x += p.vx * (dt/1000);
      p.y += p.vy * (dt/1000);
      p.vx *= Math.pow(0.92, dt/16.67);
      p.vy *= Math.pow(0.98, dt/16.67);

      const tt = 1 - (p.age / p.life);
      ctx.save();
      ctx.globalAlpha = 0.9 * tt;
      ctx.fillStyle = "rgba(255,255,255,.7)";
      ctx.beginPath();
      ctx.arc(p.x,p.y,p.r*(0.6+0.6*tt),0,Math.PI*2);
      ctx.fill();
      ctx.restore();
    }
  }

  function drawBanner(dt){
    if (levelBannerT <= 0) return;
    levelBannerT = Math.max(0, levelBannerT - dt);

    const t = 1 - (levelBannerT / 900);
    const inT = clamp(t/0.25, 0, 1);
    const outT = clamp((t-0.75)/0.25, 0, 1);
    const alpha = (1 - outT) * inT;

    const scale = 0.92 + 0.12 * Math.sin(clamp(t,0,1) * Math.PI);

    const gx = padX, gy = padY, w = boardW, h = boardH;
    const cx = gx + w/2;
    const cy = gy + h*0.22;

    ctx.save();
    ctx.globalAlpha = alpha;
    ctx.translate(cx, cy);
    ctx.scale(scale, scale);

    ctx.shadowColor = "rgba(170,220,255,.55)";
    ctx.shadowBlur = 24;

    const bw = 220, bh = 46;
    drawRoundedRect(ctx, -bw/2, -bh/2, bw, bh, 16);
    const grad = ctx.createLinearGradient(-bw/2,-bh/2,bw/2,bh/2);
    grad.addColorStop(0, "rgba(120,255,220,.22)");
    grad.addColorStop(1, "rgba(160,180,255,.22)");
    ctx.fillStyle = grad;
    ctx.fill();

    ctx.shadowBlur = 0;
    ctx.strokeStyle = "rgba(255,255,255,.18)";
    ctx.lineWidth = 1;
    drawRoundedRect(ctx, -bw/2, -bh/2, bw, bh, 16);
    ctx.stroke();

    ctx.fillStyle = "rgba(255,255,255,.92)";
    ctx.font = "900 18px system-ui, -apple-system, Segoe UI, Roboto, Arial";
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.fillText(levelBannerText, 0, 0);

    ctx.restore();
  }

  function draw(){
    ctx.clearRect(0,0,gameCanvas.width, gameCanvas.height);

    if (shakeTime > 0){
      shakeTime = Math.max(0, shakeTime - frameDT);
      const tt = shakeTime / shakeDur;
      const mag = shakeMag * tt;
      const ox = (Math.random()*2-1) * mag;
      const oy = (Math.random()*2-1) * mag;

      ctx.save();
      ctx.translate(ox, oy);
      drawScene();
      ctx.restore();
    } else {
      drawScene();
    }

    drawBanner(frameDT);
  }

  function drawScene(){
    drawGrid();
    drawHintGhost(frameDT);
    drawGhost();
    drawBoardCells();
  }

  // ------------------ Mini canvases ------------------
  function roundRectMini(c,x,y,w,h,r){
    c.beginPath();
    c.moveTo(x+r,y);
    c.arcTo(x+w,y,x+w,y+h,r);
    c.arcTo(x+w,y+h,x,y+h,r);
    c.arcTo(x,y+h,x,y,r);
    c.arcTo(x,y,x+w,y,r);
    c.closePath();
  }

  function drawMiniBg(c, w, h){
    const bg = c.createLinearGradient(0,0,w,h);
    bg.addColorStop(0, "rgba(21,33,74,.65)");
    bg.addColorStop(1, "rgba(13,22,54,.70)");
    c.fillStyle = bg;
    c.fillRect(0,0,w,h);

    c.save();
    c.globalAlpha = 0.18;
    c.strokeStyle = "rgba(255,255,255,.18)";
    c.lineWidth = 1;
    const cell = 22;
    for (let y=0; y<=Math.floor(h/cell); y++){
      c.beginPath(); c.moveTo(0,y*cell); c.lineTo(w,y*cell); c.stroke();
    }
    for (let x=0; x<=Math.floor(w/cell); x++){
      c.beginPath(); c.moveTo(x*cell,0); c.lineTo(x*cell,h); c.stroke();
    }
    c.restore();
  }

  function drawMiniPiece(c, type, boxX, boxY, boxW, boxH){
    if (!type) return;
    const blocks = SHAPES[type][0];
    let minX=99,minY=99,maxX=-99,maxY=-99;
    for (const b of blocks){
      minX = Math.min(minX,b.x); minY = Math.min(minY,b.y);
      maxX = Math.max(maxX,b.x); maxY = Math.max(maxY,b.y);
    }
    const bw = (maxX-minX+1), bh = (maxY-minY+1);
    const cell = Math.floor(Math.min(boxW/(bw+1), boxH/(bh+1)));
    const ox = boxX + Math.floor((boxW - bw*cell)/2) - minX*cell;
    const oy = boxY + Math.floor((boxH - bh*cell)/2) - minY*cell;

    const [c1,c2,glow] = PIECE_GRADS[type];
    for (const b of blocks){
      const x = ox + b.x*cell;
      const y = oy + b.y*cell;
      const g = c.createLinearGradient(x,y,x+cell,y+cell);
      g.addColorStop(0,c1); g.addColorStop(1,c2);

      c.save();
      c.shadowColor = glow;
      c.shadowBlur = 10;
      c.fillStyle = g;
      roundRectMini(c, x+2, y+2, cell-4, cell-4, 8);
      c.fill();
      c.shadowBlur = 0;
      c.strokeStyle = "rgba(255,255,255,.14)";
      c.lineWidth = 1;
      roundRectMini(c, x+2, y+2, cell-4, cell-4, 8);
      c.stroke();
      c.restore();
    }
  }

  function drawHold(){
    hctx.clearRect(0,0,holdCanvas.width, holdCanvas.height);
    drawMiniBg(hctx, holdCanvas.width, holdCanvas.height);
    drawMiniPiece(hctx, holdType, 0, 0, holdCanvas.width, holdCanvas.height);
  }

  function drawNextQueue(){
    ensureQueue();
    nctx.clearRect(0,0,nextCanvas.width, nextCanvas.height);
    drawMiniBg(nctx, nextCanvas.width, nextCanvas.height);

    const count = NEXT_SHOW;
    const slotH = Math.floor(nextCanvas.height / count);

    for (let i=0; i<count; i++){
      const y = i * slotH;
      if (i > 0){
        nctx.save();
        nctx.globalAlpha = 0.16;
        nctx.strokeStyle = "rgba(255,255,255,.16)";
        nctx.beginPath();
        nctx.moveTo(10, y);
        nctx.lineTo(nextCanvas.width-10, y);
        nctx.stroke();
        nctx.restore();
      }
      drawMiniPiece(nctx, nextQueue[i]?.type ?? null, 0, y, nextCanvas.width, slotH);
    }
  }

  function drawTargetPreview(){
    tctx.clearRect(0,0,targetCanvas.width, targetCanvas.height);
    drawMiniBg(tctx, targetCanvas.width, targetCanvas.height);

    const W = targetCanvas.width;
    const H = targetCanvas.height;

    const title = (trainerOn && trainerTarget) ? trainerTarget.title : "Trainer Off";
    tctx.save();
    tctx.fillStyle = "rgba(233,238,255,.88)";
    tctx.font = "800 12px system-ui, -apple-system, Segoe UI, Roboto, Arial";
    tctx.textAlign = "left";
    tctx.textBaseline = "top";
    tctx.fillText(title, 10, 8);
    tctx.restore();
  }

  // ------------------ Spawn / queue ------------------
  function spawnFromQueue(){
    ensureQueue();
    const next = nextQueue.shift();
    current = spawnPiece(next.type);
    current.x = 3; current.y = 0; current.rot = 0;
    current.rx = current.x; current.ry = current.y;
    lastAction = "none";
    lastRotation = null;
    canHold = true;

    ensureQueue();
    drawNextQueue();

    beginPieceInputTracking();
  }

  // ------------------ Lock / clear (simple modern scoring) ------------------
  function lockPiece(){
    const stepRes = validateStepOnLock();
    if (stepRes.active){
      if (!stepRes.ok){
        trainerMisses += 1;
        if (strictMode){
          loadPreset(activePreset);
          return;
        }
      }
      trainerStepIndex = Math.min(trainerStepIndex + 1, trainerSteps.length);
      updateTrainerHud();
    }

    finalizeFinesseForLockedPiece();

    const blocks = getBlocks(current);
    for (const b of blocks){
      if (b.y < 0) continue;
      board[b.y][b.x] = { type: current.type };
    }
    piecesLocked += 1;
    SFX.lock();

    const full = [];
    for (let y=HIDDEN_ROWS; y<TOTAL_ROWS; y++){
      if (board[y].every(cell => cell !== null)) full.push(y);
    }

    if (full.length){
      // clear
      full.sort((a,b)=>a-b);
      for (const y of full){
        board.splice(y,1);
        board.splice(HIDDEN_ROWS, 0, new Array(COLS).fill(null));
      }

      const n = full.length;
      const base = (LINE_SCORE[n] || (n*120)) * level;
      score += base;
      lines += n;

      const prevLevel = level;
      level = 1 + Math.floor(lines / LINES_PER_LEVEL);
      if (level > prevLevel) showLevelBanner(level);

      recalcSpeed();
      setLastClear(`${n} line${n>1?"s":""} (+${base})`, true);
      SFX.clear(n);
      startShake(7, 140);
      updateHud();
    } else {
      setLastClear("LOCK");
    }

    spawnFromQueue();
    if (collides(current)) endGame();
  }

  // ------------------ Reset / preset / analytics ------------------
  function resetAnalyticsAndRecording(){
    runStartPerf = performance.now();
    piecesLocked = 0;
    actionLog = [];
    actionCounts = {};
    actionTotal = 0;
    for (const k of Object.keys(finByPiece)){
      finByPiece[k].ok = 0;
      finByPiece[k].err = 0;
    }
  }

  function resetGame(keepTrainer=false){
    board = makeBoard();
    score = 0; lines = 0; level = 1;
    paused = false; gameOver = false;
    touchingGround = false; groundSince = 0;
    dropAcc = 0;

    holdType = null;
    canHold = true;

    finessePieces = 0;
    finesseErrors = 0;
    finesseOptimalTotal = 0;
    finesseActualTotal = 0;
    finesseLastText = "‚Äî";

    resetAnalyticsAndRecording();

    if (!keepTrainer){
      trainerOn = false;
      activePreset = "none";
      trainerSteps = [];
      trainerStepIndex = 0;
      trainerMisses = 0;
      trainerTarget = null;
    } else {
      trainerTarget = PRESETS[activePreset]?.target || null;
    }

    bag = [];
    nextQueue = [];
    refillBag();

    ensureQueue();
    spawnFromQueue();

    overlayGameOver.classList.remove('show');
    setToast("", false);

    recalcSpeed();
    updateHud();
    drawHold();
    drawNextQueue();
    drawTargetPreview();
    setLastClear("‚Äî");

    computeHint();

    if (collides(current)) endGame();
  }

  function loadPreset(presetKey){
    activePreset = presetKey;
    const p = PRESETS[presetKey] || PRESETS.none;

    trainerSteps = p.steps.slice();
    trainerStepIndex = 0;
    trainerMisses = 0;
    trainerTarget = p.target;

    trainerOn = (presetKey !== "none") ? true : trainerOn;

    setLastClear(`TRAINER: ${p.title}`, true);

    resetGame(true);

    nextQueue = [];
    ensureQueue();
    drawNextQueue();
    drawTargetPreview();

    computeHint();
    updateHud();
  }

  // ------------------ Game loop ------------------
  function stepDown(){
    // (during replay we allow drop to happen naturally but do not allow manual move functions)
    const ny = current.y + 1;
    if (!collides(current, current.rot, {x:current.x, y:ny})){
      current.y = ny;
      touchingGround = false;
      return true;
    }
    if (!touchingGround){ touchingGround = true; groundSince = 0; }
    return false;
  }

  function replayPump(){
    if (!replayMode) return;
    const tNow = performance.now() - replayStartPerf;
    while (replayIdx < actionLog.length && actionLog[replayIdx].t <= tNow){
      const ev = actionLog[replayIdx++];
      applyRecordedAction(ev);
    }
    if (replayIdx >= actionLog.length && gameOver){
      replayMode = false;
      updateHud();
      setToast("Replay finished", true);
      setTimeout(()=>setToast("", false), 900);
    }
  }

  function update(dt){
    softDropHeld = kbSoftDropHeld || gpSoftDropHeld;

    if (!paused && !gameOver){
      computeHint();

      pollGamepad();
      if (replayMode) replayPump();

      if (softDropHeld && !replayMode){
        softDropAcc += dt;
        while (softDropAcc >= SOFT_DROP_RATE){
          softDropAcc -= SOFT_DROP_RATE;
          if (!collides(current, current.rot, {x:current.x, y:current.y+1})){
            current.y += 1;
            score += 1;
          } else break;
        }
        updateHud();
      } else {
        softDropAcc = 0;
      }

      dropAcc += dt;
      while (dropAcc >= dropInterval){
        dropAcc -= dropInterval;
        stepDown();
      }

      if (touchingGround){
        groundSince += dt;
        if (groundSince >= LOCK_DELAY){
          lockPiece();
          touchingGround = false;
          groundSince = 0;
        }
      }
    }
  }

  function frame(t){
    frameDT = Math.min(34, t - lastTime || 16.67);
    lastTime = t;

    update(frameDT);
    draw();
    drawCurrentPiece(frameDT);
    drawParticles(frameDT);

    requestAnimationFrame(frame);
  }

  // ------------------ UI events ------------------
  pauseBtn.addEventListener('click', ()=>togglePause());
  restartBtn.addEventListener('click', ()=>{
    if (replayMode) stopReplay();
    else resetGame(false);
  });

  replayBtn.addEventListener('click', ()=>startReplay());
  replayBtn2.addEventListener('click', ()=>startReplay());

  soundToggle.addEventListener('click', ()=>{
    soundEnabled = !soundEnabled;
    setSoundUI();
    if (soundEnabled){ ensureAudio(); SFX.rotate(); }
  });

  trainerToggle.addEventListener('click', ()=>{
    if (replayMode) return;
    trainerOn = !trainerOn;
    if (!trainerOn){
      activePreset = "none";
      trainerSteps = [];
      trainerStepIndex = 0;
      trainerMisses = 0;
      trainerTarget = null;
      setLastClear("TRAINER OFF", true);
      resetGame(false);
    } else {
      setLastClear("TRAINER ON ‚Äî pick a preset", true);
      updateHud();
      drawTargetPreview();
    }
    updateHud();
  });

  hintToggle.addEventListener('click', ()=>{
    if (replayMode) return;
    hintsOn = !hintsOn;
    updateHud();
  });

  outlineToggle.addEventListener('click', ()=>{
    if (replayMode) return;
    outlineOn = !outlineOn;
    updateHud();
  });

  strictToggle.addEventListener('click', ()=>{
    if (replayMode) return;
    strictMode = !strictMode;
    updateHud();
    setLastClear(strictMode ? "STRICT MODE ON" : "STRICT MODE OFF", true);
  });

  loadPresetBtn.addEventListener('click', ()=>{
    if (replayMode) return;
    const key = presetSelect.value;
    if (key === "none"){
      activePreset = "none";
      trainerSteps = [];
      trainerStepIndex = 0;
      trainerMisses = 0;
      trainerTarget = null;
      drawTargetPreview();
      setLastClear("Preset cleared", true);
      resetGame(true);
      return;
    }
    loadPreset(key);
  });

  resetPresetBtn.addEventListener('click', ()=>{
    if (replayMode) return;
    if (!trainerOn || activePreset === "none"){
      setLastClear("No preset active", true);
      return;
    }
    loadPreset(activePreset);
  });

  dasSlider.addEventListener('input', ()=>{
    DAS = parseInt(dasSlider.value,10);
    dasVal.textContent = String(DAS);
  });
  arrSlider.addEventListener('input', ()=>{
    ARR = parseInt(arrSlider.value,10);
    arrVal.textContent = String(ARR);
  });

  gravitySelect.addEventListener('change', ()=>{
    if (replayMode) return;
    gravityMode = gravitySelect.value;
    recalcSpeed();
    setLastClear(`GRAVITY: ${gravityMode.toUpperCase()}`, true);
  });

  ghostToggle.addEventListener('click', ()=>{ showGhost = !showGhost; updateHud(); });
  fxToggle.addEventListener('click', ()=>{ enableFX = !enableFX; updateHud(); });
  shakeToggle.addEventListener('click', ()=>{ enableShake = !enableShake; updateHud(); });

  clearLeaderboardBtn.addEventListener('click', ()=>{
    leaderboard = [];
    saveHighAndLeaderboard();
    updateLeaderboardUI();
  });

  resetBindsBtn.addEventListener('click', ()=>{
    if (replayMode) return;
    binds = {...DEFAULT_BINDS};
    saveBinds();
    renderBindUI();
    setToast("Keybinds reset", true);
    setTimeout(()=>setToast("", false), 650);
  });

  // ------------------ Init ------------------
  function init(){
    loadHighAndLeaderboard();
    loadBinds();
    renderBindUI();
    setSoundUI();
    updateLeaderboardUI();
    loadLastReplay();

    setBagSeed(randomSeed());

    dasSlider.value = String(DAS);
    arrSlider.value = String(ARR);
    gravitySelect.value = gravityMode;

    updateHud();
    resetGame(false);
    requestAnimationFrame(frame);
  }

  init();
})();
</script>
<script>
  if ("serviceWorker" in navigator) {
    window.addEventListener("load", () => {
      navigator.serviceWorker.register("service-worker.js");
    });
  }
</script>
</body>
</html>
